/* dijkstra.c
 * Simple Dijkstra implementation (O(N^2)) using adjacency matrix.
 * Works for directed or undirected graphs with non-negative weights.
 *
 * Compile:
 *   gcc dijkstra.c -o dijkstra
 *
 * Run:
 *   ./dijkstra
 *
 * Input format (interactive):
 *   Enter number of nodes: N
 *   Enter number of edges: M
 *   Then M lines: u v w   (1-based node indices; w >= 0)
 *   Is the graph undirected? (1 for yes, 0 for no):
 *   Enter source node:
 *
 * Example:
 *   N=6 M=7
 *   edges:
 *     1 2 2
 *     1 3 4
 *     2 3 1
 *     2 4 7
 *     3 5 3
 *     4 6 5
 *     5 6 2
 *   undirected = 1
 *   source = 1
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAXN 500            /* maximum number of nodes (adjust if needed) */
#define INF  INT_MAX/4     /* large value representing infinity */

/* Print the shortest path from source to target using parent[] */
void print_path(int parent[], int src, int dest) {
    if (dest == src) {
        printf("%d", src);
        return;
    }
    if (parent[dest] == -1) {
        printf("unreachable");
        return;
    }
    /* build path in reverse */
    int stack[MAXN];
    int top = 0;
    int cur = dest;
    while (cur != -1) {
        stack[top++] = cur;
        if (cur == src) break;
        cur = parent[cur];
    }
    /* if last element isn't source, unreachable */
    if (top == 0 || stack[top-1] != src) {
        printf("unreachable");
        return;
    }
    /* print in forward order */
    for (int i = top - 1; i >= 0; --i) {
        printf("%d", stack[i]);
        if (i > 0) printf(" -> ");
    }
}

/* Simple Dijkstra O(N^2) using adjacency matrix */
void dijkstra(int n, int adj[][MAXN], int src, int dist[], int parent[]) {
    int visited[MAXN];
    for (int i = 0; i < n; ++i) {
        dist[i] = INF;
        visited[i] = 0;
        parent[i] = -1;
    }
    dist[src] = 0;

    for (int iter = 0; iter < n; ++iter) {
        /* find unvisited node with smallest dist */
        int u = -1;
        int best = INF;
        for (int i = 0; i < n; ++i) {
            if (!visited[i] && dist[i] < best) {
                best = dist[i];
                u = i;
            }
        }
        if (u == -1) break; /* remaining nodes unreachable */
        visited[u] = 1;

        /* relax edges u -> v */
        for (int v = 0; v < n; ++v) {
            if (!visited[v] && adj[u][v] < INF) {
                long long nd = (long long)dist[u] + adj[u][v];
                if (nd < dist[v]) {
                    dist[v] = (int)nd;
                    parent[v] = u;
                }
            }
        }
    }
}

int main(void) {
    int n, m;
    printf("Enter number of nodes: ");
    if (scanf("%d", &n) != 1 || n <= 0 || n > MAXN) {
        fprintf(stderr, "Invalid number of nodes (1..%d)\n", MAXN);
        return 1;
    }

    printf("Enter number of edges: ");
    if (scanf("%d", &m) != 1 || m < 0) {
        fprintf(stderr, "Invalid number of edges\n");
        return 1;
    }

    /* adjacency matrix init */
    static int adj[MAXN][MAXN];
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            adj[i][j] = INF;

    printf("Enter edges (u v w) one per line (1-based indices):\n");
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        if (scanf("%d %d %d", &u, &v, &w) != 3) {
            fprintf(stderr, "Invalid edge input at line %d\n", i+1);
            return 1;
        }
        if (u < 1 || u > n || v < 1 || v > n || w < 0) {
            fprintf(stderr, "Invalid edge values: u,v in [1..%d], w >= 0\n", n);
            return 1;
        }
        /* convert to 0-based */
        u--; v--;
        /* if multiple edges between same nodes, keep smallest weight */
        if (w < adj[u][v]) adj[u][v] = w;
    }

    int undirected;
    printf("Is the graph undirected? (1 for yes, 0 for no): ");
    if (scanf("%d", &undirected) != 1) {
        fprintf(stderr, "Invalid input\n");
        return 1;
    }
    if (undirected) {
        /* mirror edges */
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (adj[i][j] < INF && adj[j][i] == INF)
                    adj[j][i] = adj[i][j];
    }

    int source1based;
    printf("Enter source node (1..%d): ", n);
    if (scanf("%d", &source1based) != 1 || source1based < 1 || source1based > n) {
        fprintf(stderr, "Invalid source\n");
        return 1;
    }
    int src = source1based - 1;

    static int dist[MAXN];
    static int parent[MAXN];

    dijkstra(n, adj, src, dist, parent);

    printf("\nShortest distances from node %d:\n", source1based);
    for (int i = 0; i < n; ++i) {
        if (dist[i] >= INF/2) {
            printf("  %d -> %d = unreachable\n", source1based, i+1);
        } else {
            printf("  %d -> %d = %d\n", source1based, i+1, dist[i]);
        }
    }

    printf("\nShortest paths from source:\n");
    for (int i = 0; i < n; ++i) {
        printf("  Path %d -> %d: ", source1based, i+1);
        print_path(parent, src, i);
        printf("\n");
    }

    return 0;
}
